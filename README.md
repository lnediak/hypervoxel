This repo documents my attempts at creating a renderer for a higher-dimensional open world block game with Minecraft-like terrain generation.

I've only ever run these on Ubuntu with a Nvidia GPU, by the way.

`glad/gl.h` is generated by [glad2](https://gen.glad.sh/), `lodepng/*` is copied from [lodepng](https://github.com/lvandeve/lodepng).

Branches:
- master: Just run `make` and `./basic_test` and it should launch a window showing a scuffed-looking thing that is
actually movement in a four-dimensional block world while looking in a slice that is orthogonal to the direction of motion. 
Note that this is just movement in a straight line, so there will be some weird artifacts when inside blocks.
  - Depends on: [glfw3](https://github.com/glfw/glfw) (most Linux package managers have this, I think)
  - If you want to change the render, just edit `basic_test.cpp`.
  - The way I did the rendering here is basically that I enumerate the "edges" (which are (N-2)-dimensional surfaces) of hypercubes that intersect the slice
  (where N is the number of dimensions), adding them to a concurrent hashtable, and then I go through it,
  turning them into lists of triangles to render.
  Not a viable approach, since the render distance is really restricted (due to how slow it is), and it's just one out of the multiple slices
  necessary (and there's basically no way to reuse much information between slices).
- scuff: Crashes.
- rewrite: For a render, `make` in `test_terrain_renderer` and run the `main` there. Will generate an image in `result.png` and display how long it took to generate.
It is too long for a real-time application, but compared to how slow it is in `master` (relative to the render distance), it's a vast improvement.
  - Depends on: OpenCL (just make sure that `clinfo` shows at least 1 GPU device),
  [OpenCL C++ Headers](https://github.com/KhronosGroup/OpenCL-CLHPP) (I think most package managers have this too; it was installed by default for me)
  - If you want to change the rendered scene, edit `test_terrain_renderer/main.cpp`.
  - The way this one works is that it generates more than enough of the terrain using OpenCL, and then raycasts through it (as in grid raycasting).
  One option for making this actually run in real-time would be to make the slices low-resolution
  (like I did in [labyrinth-scuffed](https://github.com/lnediak/labyrinth-scuffed)), thus making the raycasting
  much less expensive, and to significantly optimize the terrain generation, perhaps by generating less terrain that doesn't
  intersect the slice being rendered and maybe doing some level-of-detail stuff at further distances.
  - `theory/doc.tex` was just my notes for implementing `terrain_indexer.hpp`.

